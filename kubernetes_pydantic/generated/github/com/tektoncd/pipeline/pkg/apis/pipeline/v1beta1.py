# generated by datamodel-codegen:
#   filename:  tekton.swagger.json
#   timestamp: 2022-03-30T02:38:37+00:00

from __future__ import annotations

from typing import Dict, List, Optional, NewType, Union

from pydantic import BaseModel, Field

from kubernetes_pydantic.generated.github.com.tektoncd.pipeline.pkg.apis.pipeline import v1alpha1, pod, v1, knative
from kubernetes_pydantic.generated.github.com.tektoncd.pipeline.pkg.apis.run import v1alpha1 as v1alpha1_1
from kubernetes_pydantic.generated.io.k8s.apimachinery.pkg import runtime

# class ArrayOrString(BaseModel):
#     class Config:
#         allow_population_by_field_name = True
#
#     array_val: List[str] = Field(..., alias='arrayVal')
#     string_val: str = Field(..., alias='stringVal', description='Represents the stored type of ArrayOrString.')
#     type: str
ArrayOrString = NewType('ArrayOrString', Union[str, list[str]])


class Param(BaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str
    value: ArrayOrString


class ParamSpec(BaseModel):
    class Config:
        allow_population_by_field_name = True

    default: Optional[ArrayOrString] = Field(
        None,
        description='Default is the value a parameter takes if no input value is supplied. If default is set, a Task may be executed without a supplied value for the parameter.',
    )
    description: Optional[str] = Field(
        None, description='Description is a user-facing description of the parameter that may be used to populate a UI.'
    )
    name: str = Field(..., description='Name declares the name by which a parameter is referenced.')
    type: Optional[str] = Field(
        None,
        description='Type is the user-specified type of the parameter. The possible generated are currently "string" and "array", and "string" is the default.',
    )


class PipelineDeclaredResource(BaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str = Field(
        ...,
        description='Name is the name that will be used by the Pipeline to refer to this resource. It does not directly correspond to the name of any PipelineResources Task inputs or outputs, and it does not correspond to the actual names of the PipelineResources that will be bound in the PipelineRun.',
    )
    optional: Optional[bool] = Field(
        None,
        description='Optional declares the resource as optional. optional: true - the resource is considered optional optional: false - the resource is considered required (default/equivalent of not specifying it)',
    )
    type: str = Field(..., description='Type is the type of the PipelineResource.')


class PipelineRef(BaseModel):
    class Config:
        allow_population_by_field_name = True

    api_version: Optional[str] = Field(None, alias='apiVersion', description='API version of the referent')
    bundle: Optional[str] = Field(None, description='Bundle url reference to a Tekton Bundle.')
    name: Optional[str] = Field(
        None, description='Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names'
    )


class PipelineResourceRef(BaseModel):
    class Config:
        allow_population_by_field_name = True

    api_version: Optional[str] = Field(None, alias='apiVersion', description='API version of the referent')
    name: Optional[str] = Field(
        None, description='Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names'
    )


class PipelineResourceResult(BaseModel):
    class Config:
        allow_population_by_field_name = True

    key: str
    resource_name: Optional[str] = Field(None, alias='resourceName')
    resource_ref: Optional[PipelineResourceRef] = Field(
        None,
        alias='resourceRef',
        description='The field ResourceRef should be deprecated and removed in the next API version. See https://github.com/tektoncd/pipeline/issues/2694 for more information.',
    )
    type: Optional[int] = None
    value: str


class PipelineResult(BaseModel):
    class Config:
        allow_population_by_field_name = True

    description: Optional[str] = Field('', description='Description is a human-readable description of the result')
    name: str = Field(..., description='Name the given name')
    value: str = Field(..., description='Value the expression used to retrieve the value')


class PipelineRunResult(BaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str = Field(..., description="Name is the result's name as declared by the Pipeline")
    value: str = Field(..., description='Value is the result returned from the execution of this PipelineRun')


class PipelineRunSpecServiceAccountName(BaseModel):
    class Config:
        allow_population_by_field_name = True

    service_account_name: Optional[str] = Field(None, alias='serviceAccountName')
    task_name: Optional[str] = Field(None, alias='taskName')


class PipelineTaskInputResource(BaseModel):
    class Config:
        allow_population_by_field_name = True

    from_: Optional[List[str]] = Field(
        None,
        alias='from',
        description='From is the list of PipelineTask names that the resource has to come from. (Implies an ordering in the execution graph.)',
    )
    name: str = Field(..., description='Name is the name of the PipelineResource as declared by the Task.')
    resource: str = Field(..., description='Resource is the name of the DeclaredPipelineResource to use.')


class PipelineTaskMetadata(BaseModel):
    class Config:
        allow_population_by_field_name = True

    annotations: Optional[Dict[str, str]] = None
    labels: Optional[Dict[str, str]] = None


class PipelineTaskOutputResource(BaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str = Field(..., description='Name is the name of the PipelineResource as declared by the Task.')
    resource: str = Field(..., description='Resource is the name of the DeclaredPipelineResource to use.')


class PipelineTaskParam(BaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str
    value: str


class PipelineTaskResources(BaseModel):
    class Config:
        allow_population_by_field_name = True

    inputs: Optional[List[PipelineTaskInputResource]] = Field(
        None,
        description='Inputs holds the mapping from the PipelineResources declared in DeclaredPipelineResources to the input PipelineResources required by the Task.',
    )
    outputs: Optional[List[PipelineTaskOutputResource]] = Field(
        None,
        description='Outputs holds the mapping from the PipelineResources declared in DeclaredPipelineResources to the input PipelineResources required by the Task.',
    )


class PipelineTaskRun(BaseModel):
    class Config:
        allow_population_by_field_name = True

    name: Optional[str] = None


class PipelineWorkspaceDeclaration(BaseModel):
    class Config:
        allow_population_by_field_name = True

    description: Optional[str] = Field(
        None,
        description='Description is a human readable string describing how the workspace will be used in the Pipeline. It can be useful to include a bit of detail about which tasks are intended to have access to the data on the workspace.',
    )
    name: str = Field(..., description='Name is the name of a workspace to be provided by a PipelineRun.')
    optional: Optional[bool] = Field(
        None,
        description='Optional marks a Workspace as not being required in PipelineRuns. By default this field is false and so declared workspaces are required.',
    )


class ResolverParam(BaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str = Field(
        ..., alias='Name', description='Name is the name of the parameter that will be passed to the resolver.'
    )
    value: str = Field(
        ...,
        alias='Value',
        description='Value is the string value of the parameter that will be passed to the resolver.',
    )


class ResolverRef(BaseModel):
    class Config:
        allow_population_by_field_name = True

    resolver: Optional[str] = Field(
        None,
        description='Resolver is the name of the resolver that should perform resolution of the referenced Tekton resource, such as "git".',
    )
    resource: Optional[List[ResolverParam]] = Field(
        None,
        description='Resource contains the parameters used to identify the referenced Tekton resource. Example entries might include "repo" or "path" but the set of params ultimately depends on the chosen resolver.',
    )


class ResultRef(BaseModel):
    class Config:
        allow_population_by_field_name = True

    pipeline_task: str = Field(..., alias='PipelineTask')
    result: str = Field(..., alias='Result')


class TaskRef(BaseModel):
    class Config:
        allow_population_by_field_name = True

    api_version: Optional[str] = Field(None, alias='apiVersion', description='API version of the referent')
    bundle: Optional[str] = Field(None, description='Bundle url reference to a Tekton Bundle.')
    kind: Optional[str] = Field(
        None, description='TaskKind indicates the kind of the task, namespaced or cluster scoped.'
    )
    name: Optional[str] = Field(
        None, description='Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names'
    )


class TaskResource(BaseModel):
    class Config:
        allow_population_by_field_name = True

    description: Optional[str] = Field(
        None,
        description='Description is a user-facing description of the declared resource that may be used to populate a UI.',
    )
    name: str = Field(
        ...,
        description="Name declares the name by which a resource is referenced in the definition. Resources may be referenced by name in the definition of a Task's steps.",
    )
    optional: Optional[bool] = Field(
        None,
        description='Optional declares the resource as optional. By default optional is set to false which makes a resource required. optional: true - the resource is considered optional optional: false - the resource is considered required (equivalent of not specifying it)',
    )
    target_path: Optional[str] = Field(
        None,
        alias='targetPath',
        description='TargetPath is the path in workspace directory where the resource will be copied.',
    )
    type: str = Field(..., description='Type is the type of this resource;')


class TaskResources(BaseModel):
    class Config:
        allow_population_by_field_name = True

    inputs: Optional[List[TaskResource]] = Field(
        None,
        description='Inputs holds the mapping from the PipelineResources declared in DeclaredPipelineResources to the input PipelineResources required by the Task.',
    )
    outputs: Optional[List[TaskResource]] = Field(
        None,
        description='Outputs holds the mapping from the PipelineResources declared in DeclaredPipelineResources to the input PipelineResources required by the Task.',
    )


class TaskResult(BaseModel):
    class Config:
        allow_population_by_field_name = True

    description: Optional[str] = Field('', description='Description is a human-readable description of the result')
    name: str = Field(..., description='Name the given name')


class TaskRunDebug(BaseModel):
    class Config:
        allow_population_by_field_name = True

    breakpoint: Optional[List[str]] = None


class TaskRunResult(BaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str = Field(..., description='Name the given name')
    value: str = Field(..., description='Value the given value of the result')


class WhenExpression(BaseModel):
    class Config:
        allow_population_by_field_name = True

    input: str = Field(
        ...,
        description='Input is the string for guard checking which can be a static input or an output from a parent Task',
    )
    operator: str = Field(..., description="Operator that represents an Input's relationship to the values")
    values: List[str] = Field(
        ...,
        description='Values is an array of strings, which is compared against the input, for guard checking It must be non-empty',
    )


class WorkspaceDeclaration(BaseModel):
    class Config:
        allow_population_by_field_name = True

    description: Optional[str] = Field(
        None, description='Description is an optional human readable description of this volume.'
    )
    mount_path: Optional[str] = Field(
        None,
        alias='mountPath',
        description='MountPath overrides the directory that the volume will be made available at.',
    )
    name: str = Field(..., description='Name is the name by which you can bind the volume at runtime.')
    optional: Optional[bool] = Field(
        None,
        description='Optional marks a Workspace as not being required in TaskRuns. By default this field is false and so declared workspaces are required.',
    )
    read_only: Optional[bool] = Field(
        None,
        alias='readOnly',
        description='ReadOnly dictates whether a mounted volume is writable. By default this field is false and so mounted volumes are writable.',
    )


class WorkspacePipelineTaskBinding(BaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str = Field(..., description='Name is the name of the workspace as declared by the task')
    sub_path: Optional[str] = Field(
        None,
        alias='subPath',
        description='SubPath is optionally a directory on the volume which should be used for this binding (i.e. the volume will be mounted at this sub directory).',
    )
    workspace: str = Field(..., description='Workspace is the name of the workspace declared by the pipeline')


class WorkspaceUsage(BaseModel):
    class Config:
        allow_population_by_field_name = True

    mount_path: str = Field(
        ...,
        alias='mountPath',
        description="MountPath is the path that the workspace should be mounted to inside the Step or Sidecar, overriding any MountPath specified in the Task's WorkspaceDeclaration.",
    )
    name: str = Field(..., description='Name is the name of the workspace this Step or Sidecar wants access to.')


class CloudEventDeliveryState(BaseModel):
    class Config:
        allow_population_by_field_name = True

    condition: Optional[str] = Field(None, description='Current status')
    message: str = Field(..., description='Error is the text of error (if any)')
    retry_count: int = Field(
        ..., alias='retryCount', description='RetryCount is the number of attempts of sending the cloud event'
    )
    sent_at: Optional[v1.Time] = Field(
        None, alias='sentAt', description='SentAt is the time at which the last attempt to send the event was made'
    )


class ConditionCheckStatus(BaseModel):
    class Config:
        allow_population_by_field_name = True

    annotations: Optional[Dict[str, str]] = Field(
        None,
        description='Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.',
    )
    check: Optional[v1.ContainerState] = Field({}, description='Check describes the state of the check container.')
    completion_time: Optional[v1.Time] = Field(
        None, alias='completionTime', description='CompletionTime is the time the check pod completed.'
    )
    conditions: Optional[List[knative.Condition]] = Field(
        None, description="Conditions the latest available observations of a resource's current state."
    )
    observed_generation: Optional[int] = Field(
        None,
        alias='observedGeneration',
        description="ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
    )
    pod_name: str = Field(
        ...,
        alias='podName',
        description='PodName is the name of the pod responsible for executing this condition check.',
    )
    start_time: Optional[v1.Time] = Field(
        None, alias='startTime', description='StartTime is the time the check is actually started.'
    )


class ConditionCheckStatusFields(BaseModel):
    class Config:
        allow_population_by_field_name = True

    check: Optional[v1.ContainerState] = Field({}, description='Check describes the state of the check container.')
    completion_time: Optional[v1.Time] = Field(
        None, alias='completionTime', description='CompletionTime is the time the check pod completed.'
    )
    pod_name: str = Field(
        ...,
        alias='podName',
        description='PodName is the name of the pod responsible for executing this condition check.',
    )
    start_time: Optional[v1.Time] = Field(
        None, alias='startTime', description='StartTime is the time the check is actually started.'
    )


class PipelineResourceBinding(BaseModel):
    class Config:
        allow_population_by_field_name = True

    name: Optional[str] = Field(
        None, description="Name is the name of the PipelineResource in the Pipeline's declaration"
    )
    resource_ref: Optional[PipelineResourceRef] = Field(
        None,
        alias='resourceRef',
        description='ResourceRef is a reference to the instance of the actual PipelineResource that should be used',
    )
    resource_spec: Optional[v1alpha1.PipelineResourceSpec] = Field(
        None,
        alias='resourceSpec',
        description='ResourceSpec is specification of a resource that should be created and consumed by the task',
    )


class PipelineRunChildConditionCheckStatus(BaseModel):
    class Config:
        allow_population_by_field_name = True

    condition_check_name: Optional[str] = Field(None, alias='conditionCheckName')
    condition_name: Optional[str] = Field(
        None, alias='conditionName', description='ConditionName is the name of the Condition'
    )
    status: Optional[ConditionCheckStatus] = Field(
        None, description='Status is the ConditionCheckStatus for the corresponding ConditionCheck'
    )


class PipelineRunConditionCheckStatus(BaseModel):
    class Config:
        allow_population_by_field_name = True

    condition_name: Optional[str] = Field(
        None, alias='conditionName', description='ConditionName is the name of the Condition'
    )
    status: Optional[ConditionCheckStatus] = Field(
        None, description='Status is the ConditionCheckStatus for the corresponding ConditionCheck'
    )


class PipelineRunRunStatus(BaseModel):
    class Config:
        allow_population_by_field_name = True

    pipeline_task_name: Optional[str] = Field(
        None, alias='pipelineTaskName', description='PipelineTaskName is the name of the PipelineTask.'
    )
    status: Optional[v1alpha1_1.RunStatus] = Field(
        None, description='Status is the RunStatus for the corresponding Run'
    )
    when_expressions: Optional[List[WhenExpression]] = Field(
        None,
        alias='whenExpressions',
        description='WhenExpressions is the list of checks guarding the execution of the PipelineTask',
    )


class PipelineTaskCondition(BaseModel):
    class Config:
        allow_population_by_field_name = True

    condition_ref: str = Field(
        ..., alias='conditionRef', description='ConditionRef is the name of the Condition to use for the conditionCheck'
    )
    params: Optional[List[Param]] = Field(None, description='Params declare parameters passed to this Condition')
    resources: Optional[List[PipelineTaskInputResource]] = Field(
        None, description='Resources declare the resources provided to this Condition as input'
    )


class Sidecar(BaseModel):
    class Config:
        allow_population_by_field_name = True

    args: Optional[List[str]] = Field(
        None,
        description='Arguments to the entrypoint. The docker image\'s CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\'s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell',
    )
    command: Optional[List[str]] = Field(
        None,
        description='Entrypoint array. Not executed within a shell. The docker image\'s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\'s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell',
    )
    env: Optional[List[v1.EnvVar]] = Field(
        None, description='List of environment variables to set in the container. Cannot be updated.'
    )
    env_from: Optional[List[v1.EnvFromSource]] = Field(
        None,
        alias='envFrom',
        description='List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.',
    )
    image: Optional[str] = Field(
        None,
        description='Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.',
    )
    image_pull_policy: Optional[str] = Field(
        None,
        alias='imagePullPolicy',
        description='Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images',
    )
    lifecycle: Optional[v1.Lifecycle] = Field(
        None,
        description='Actions that the management system should take in response to container lifecycle events. Cannot be updated.',
    )
    liveness_probe: Optional[v1.Probe] = Field(
        None,
        alias='livenessProbe',
        description='Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes',
    )
    name: str = Field(
        ...,
        description='Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.',
    )
    ports: Optional[List[v1.ContainerPort]] = Field(
        None,
        description='List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.',
    )
    readiness_probe: Optional[v1.Probe] = Field(
        None,
        alias='readinessProbe',
        description='Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes',
    )
    resources: Optional[v1.ResourceRequirements] = Field(
        {},
        description='Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/',
    )
    script: Optional[str] = Field(
        None,
        description='Script is the contents of an executable file to execute.\n\nIf Script is not empty, the Step cannot have an Command or Args.',
    )
    security_context: Optional[v1.SecurityContext] = Field(
        None,
        alias='securityContext',
        description='SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/',
    )
    startup_probe: Optional[v1.Probe] = Field(
        None,
        alias='startupProbe',
        description="StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
    )
    stdin: Optional[bool] = Field(
        None,
        description='Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.',
    )
    stdin_once: Optional[bool] = Field(
        None,
        alias='stdinOnce',
        description='Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false',
    )
    termination_message_path: Optional[str] = Field(
        None,
        alias='terminationMessagePath',
        description="Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
    )
    termination_message_policy: Optional[str] = Field(
        None,
        alias='terminationMessagePolicy',
        description='Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.',
    )
    tty: Optional[bool] = Field(
        None,
        description="Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
    )
    volume_devices: Optional[List[v1.VolumeDevice]] = Field(
        None,
        alias='volumeDevices',
        description='volumeDevices is the list of block devices to be used by the container.',
    )
    volume_mounts: Optional[List[v1.VolumeMount]] = Field(
        None,
        alias='volumeMounts',
        description="Pod volumes to mount into the container's filesystem. Cannot be updated.",
    )
    working_dir: Optional[str] = Field(
        None,
        alias='workingDir',
        description="Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
    )
    workspaces: Optional[List[WorkspaceUsage]] = Field(
        None,
        description='This is an alpha field. You must set the "enable-api-fields" feature flag to "alpha" for this field to be supported.\n\nWorkspaces is a list of workspaces from the Task that this Sidecar wants exclusive access to. Adding a workspace to this list means that any other Step or Sidecar that does not also request this Workspace will not have access to it.',
    )


class SidecarState(BaseModel):
    class Config:
        allow_population_by_field_name = True

    container: Optional[str] = None
    image_id: Optional[str] = Field(None, alias='imageID')
    name: Optional[str] = None
    running: Optional[v1.ContainerStateRunning] = Field(None, description='Details about a running container')
    terminated: Optional[v1.ContainerStateTerminated] = Field(None, description='Details about a terminated container')
    waiting: Optional[v1.ContainerStateWaiting] = Field(None, description='Details about a waiting container')


class SkippedTask(BaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str = Field(..., description='Name is the Pipeline Task name')
    when_expressions: Optional[List[WhenExpression]] = Field(
        None,
        alias='whenExpressions',
        description='WhenExpressions is the list of checks guarding the execution of the PipelineTask',
    )


class Step(BaseModel):
    class Config:
        allow_population_by_field_name = True

    args: Optional[List[str]] = Field(
        None,
        description='Arguments to the entrypoint. The docker image\'s CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\'s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell',
    )
    command: Optional[List[str]] = Field(
        None,
        description='Entrypoint array. Not executed within a shell. The docker image\'s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\'s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell',
    )
    env: Optional[List[v1.EnvVar]] = Field(
        None, description='List of environment variables to set in the container. Cannot be updated.'
    )
    env_from: Optional[List[v1.EnvFromSource]] = Field(
        None,
        alias='envFrom',
        description='List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.',
    )
    image: Optional[str] = Field(
        None,
        description='Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.',
    )
    image_pull_policy: Optional[str] = Field(
        None,
        alias='imagePullPolicy',
        description='Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images',
    )
    lifecycle: Optional[v1.Lifecycle] = Field(
        None,
        description='Actions that the management system should take in response to container lifecycle events. Cannot be updated.',
    )
    liveness_probe: Optional[v1.Probe] = Field(
        None,
        alias='livenessProbe',
        description='Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes',
    )
    name: str = Field(
        ...,
        description='Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.',
    )
    on_error: Optional[str] = Field(
        None,
        alias='onError',
        description='OnError defines the exiting behavior of a container on error can be set to [ continue | stopAndFail ] stopAndFail indicates exit the taskRun if the container exits with non-zero exit code continue indicates continue executing the rest of the steps irrespective of the container exit code',
    )
    ports: Optional[List[v1.ContainerPort]] = Field(
        None,
        description='List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.',
    )
    readiness_probe: Optional[v1.Probe] = Field(
        None,
        alias='readinessProbe',
        description='Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes',
    )
    resources: Optional[v1.ResourceRequirements] = Field(
        {},
        description='Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/',
    )
    script: Optional[str] = Field(
        None,
        description='Script is the contents of an executable file to execute.\n\nIf Script is not empty, the Step cannot have an Command and the Args will be passed to the Script.',
    )
    security_context: Optional[v1.SecurityContext] = Field(
        None,
        alias='securityContext',
        description='SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/',
    )
    startup_probe: Optional[v1.Probe] = Field(
        None,
        alias='startupProbe',
        description="StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
    )
    stdin: Optional[bool] = Field(
        None,
        description='Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.',
    )
    stdin_once: Optional[bool] = Field(
        None,
        alias='stdinOnce',
        description='Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false',
    )
    termination_message_path: Optional[str] = Field(
        None,
        alias='terminationMessagePath',
        description="Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
    )
    termination_message_policy: Optional[str] = Field(
        None,
        alias='terminationMessagePolicy',
        description='Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.',
    )
    timeout: Optional[v1.Duration] = Field(
        None,
        description="Timeout is the time after which the step times out. Defaults to never. Refer to Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration",
    )
    tty: Optional[bool] = Field(
        None,
        description="Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
    )
    volume_devices: Optional[List[v1.VolumeDevice]] = Field(
        None,
        alias='volumeDevices',
        description='volumeDevices is the list of block devices to be used by the container.',
    )
    volume_mounts: Optional[List[v1.VolumeMount]] = Field(
        None,
        alias='volumeMounts',
        description="Pod volumes to mount into the container's filesystem. Cannot be updated.",
    )
    working_dir: Optional[str] = Field(
        None,
        alias='workingDir',
        description="Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
    )
    workspaces: Optional[List[WorkspaceUsage]] = Field(
        None,
        description='This is an alpha field. You must set the "enable-api-fields" feature flag to "alpha" for this field to be supported.\n\nWorkspaces is a list of workspaces from the Task that this Step wants exclusive access to. Adding a workspace to this list means that any other Step or Sidecar that does not also request this Workspace will not have access to it.',
    )


class StepState(BaseModel):
    class Config:
        allow_population_by_field_name = True

    container: Optional[str] = None
    image_id: Optional[str] = Field(None, alias='imageID')
    name: Optional[str] = None
    running: Optional[v1.ContainerStateRunning] = Field(None, description='Details about a running container')
    terminated: Optional[v1.ContainerStateTerminated] = Field(None, description='Details about a terminated container')
    waiting: Optional[v1.ContainerStateWaiting] = Field(None, description='Details about a waiting container')


class TaskResourceBinding(BaseModel):
    class Config:
        allow_population_by_field_name = True

    name: Optional[str] = Field(
        None, description="Name is the name of the PipelineResource in the Pipeline's declaration"
    )
    paths: Optional[List[str]] = Field(
        None,
        description='Paths will probably be removed in #1284, and then PipelineResourceBinding can be used instead. The optional Path field corresponds to a path on disk at which the Resource can be found (used when providing the resource via mounted volume, overriding the default logic to fetch the Resource).',
    )
    resource_ref: Optional[PipelineResourceRef] = Field(
        None,
        alias='resourceRef',
        description='ResourceRef is a reference to the instance of the actual PipelineResource that should be used',
    )
    resource_spec: Optional[v1alpha1.PipelineResourceSpec] = Field(
        None,
        alias='resourceSpec',
        description='ResourceSpec is specification of a resource that should be created and consumed by the task',
    )


class TaskRunInputs(BaseModel):
    class Config:
        allow_population_by_field_name = True

    params: Optional[List[Param]] = None
    resources: Optional[List[TaskResourceBinding]] = None


class TaskRunOutputs(BaseModel):
    class Config:
        allow_population_by_field_name = True

    resources: Optional[List[TaskResourceBinding]] = None


class TaskRunResources(BaseModel):
    class Config:
        allow_population_by_field_name = True

    inputs: Optional[List[TaskResourceBinding]] = Field(
        None, description='Inputs holds the inputs resources this task was invoked with'
    )
    outputs: Optional[List[TaskResourceBinding]] = Field(
        None, description='Outputs holds the inputs resources this task was invoked with'
    )


class TaskRunSidecarOverride(BaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str = Field(..., alias='Name', description='The name of the Sidecar to override.')
    resources: v1.ResourceRequirements = Field(
        ..., alias='Resources', description='The resource requirements to apply to the Sidecar.'
    )


class TaskRunStepOverride(BaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str = Field(..., alias='Name', description='The name of the Step to override.')
    resources: v1.ResourceRequirements = Field(
        ..., alias='Resources', description='The resource requirements to apply to the Step.'
    )


class TaskSpec(BaseModel):
    class Config:
        allow_population_by_field_name = True

    description: Optional[str] = Field(
        None, description='Description is a user-facing description of the task that may be used to populate a UI.'
    )
    params: Optional[List[ParamSpec]] = Field(
        None,
        description='Params is a list of input parameters required to run the task. Params must be supplied as inputs in TaskRuns unless they declare a default value.',
    )
    resources: Optional[TaskResources] = Field(
        None,
        description='Resources is a list input and output resource to run the task Resources are represented in TaskRuns as bindings to instances of PipelineResources.',
    )
    results: Optional[List[TaskResult]] = Field(None, description='Results are values that this Task can output')
    sidecars: Optional[List[Sidecar]] = Field(
        None,
        description="Sidecars are run alongside the Task's step containers. They begin before the steps start and end after the steps complete.",
    )
    step_template: Optional[v1.Container] = Field(
        None,
        alias='stepTemplate',
        description='StepTemplate can be used as the basis for all step containers within the Task, so that the steps inherit settings on the base container.',
    )
    steps: Optional[List[Step]] = Field(
        None,
        description='Steps are the steps of the build; each step is run sequentially with the source mounted into /workspace.',
    )
    volumes: Optional[List[v1.Volume]] = Field(
        None, description='Volumes is a collection of volumes that are available to mount into the steps of the build.'
    )
    workspaces: Optional[List[WorkspaceDeclaration]] = Field(
        None, description='Workspaces are the volumes that this Task requires.'
    )


class TimeoutFields(BaseModel):
    class Config:
        allow_population_by_field_name = True

    finally_: Optional[v1.Duration] = Field(
        None, alias='finally', description="Finally sets the maximum allowed duration of this pipeline's finally"
    )
    pipeline: Optional[v1.Duration] = Field(
        None,
        description='Pipeline sets the maximum allowed duration for execution of the entire pipeline. The sum of individual timeouts for tasks and finally must not exceed this value.',
    )
    tasks: Optional[v1.Duration] = Field(
        None, description="Tasks sets the maximum allowed duration of this pipeline's tasks"
    )


class WorkspaceBinding(BaseModel):
    class Config:
        allow_population_by_field_name = True

    config_map: Optional[v1.ConfigMapVolumeSource] = Field(
        None, alias='configMap', description='ConfigMap represents a configMap that should populate this workspace.'
    )
    empty_dir: Optional[v1.EmptyDirVolumeSource] = Field(
        None,
        alias='emptyDir',
        description="EmptyDir represents a temporary directory that shares a Task's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir Either this OR PersistentVolumeClaim can be used.",
    )
    name: str = Field(..., description='Name is the name of the workspace populated by the volume.')
    persistent_volume_claim: Optional[v1.PersistentVolumeClaimVolumeSource] = Field(
        None,
        alias='persistentVolumeClaim',
        description='PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. Either this OR EmptyDir can be used.',
    )
    secret: Optional[v1.SecretVolumeSource] = Field(
        None, description='Secret represents a secret that should populate this workspace.'
    )
    sub_path: Optional[str] = Field(
        None,
        alias='subPath',
        description='SubPath is optionally a directory on the volume which should be used for this binding (i.e. the volume will be mounted at this sub directory).',
    )
    volume_claim_template: Optional[v1.PersistentVolumeClaim] = Field(
        None,
        alias='volumeClaimTemplate',
        description='VolumeClaimTemplate is a template for a claim that will be created in the same namespace. The PipelineRun controller is responsible for creating a unique claim for each instance of PipelineRun.',
    )


class ChildStatusReference(BaseModel):
    class Config:
        allow_population_by_field_name = True

    api_version: Optional[str] = Field(None, alias='apiVersion')
    condition_checks: Optional[List[PipelineRunChildConditionCheckStatus]] = Field(
        None,
        alias='conditionChecks',
        description='ConditionChecks is the the list of condition checks, including their names and statuses, for the PipelineTask. Deprecated: This field will be removed when conditions are removed.',
    )
    kind: Optional[str] = None
    name: Optional[str] = Field(None, description='Name is the name of the TaskRun or Run this is referencing.')
    pipeline_task_name: Optional[str] = Field(
        None,
        alias='pipelineTaskName',
        description='PipelineTaskName is the name of the PipelineTask this is referencing.',
    )
    when_expressions: Optional[List[WhenExpression]] = Field(
        None,
        alias='whenExpressions',
        description='WhenExpressions is the list of checks guarding the execution of the PipelineTask',
    )


class CloudEventDelivery(BaseModel):
    class Config:
        allow_population_by_field_name = True

    status: Optional[CloudEventDeliveryState] = {}
    target: Optional[str] = Field(None, description='Target points to an addressable')


class ClusterTask(BaseModel):
    class Config:
        allow_population_by_field_name = True

    api_version: Optional[str] = Field(
        None,
        alias='apiVersion',
        description='APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
    )
    kind: Optional[str] = Field(
        None,
        description='Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
    )
    metadata: Optional[v1.ObjectMeta] = {}
    spec: Optional[TaskSpec] = Field({}, description='Spec holds the desired state of the Task from the client')


class ClusterTaskList(BaseModel):
    class Config:
        allow_population_by_field_name = True

    api_version: Optional[str] = Field(
        None,
        alias='apiVersion',
        description='APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
    )
    items: List[ClusterTask]
    kind: Optional[str] = Field(
        None,
        description='Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
    )
    metadata: Optional[v1.ListMeta] = {}


class EmbeddedTask(BaseModel):
    class Config:
        allow_population_by_field_name = True

    api_version: Optional[str] = Field(None, alias='apiVersion')
    description: Optional[str] = Field(
        None, description='Description is a user-facing description of the task that may be used to populate a UI.'
    )
    kind: Optional[str] = None
    metadata: Optional[PipelineTaskMetadata] = {}
    params: Optional[List[ParamSpec]] = Field(
        None,
        description='Params is a list of input parameters required to run the task. Params must be supplied as inputs in TaskRuns unless they declare a default value.',
    )
    resources: Optional[TaskResources] = Field(
        None,
        description='Resources is a list input and output resource to run the task Resources are represented in TaskRuns as bindings to instances of PipelineResources.',
    )
    results: Optional[List[TaskResult]] = Field(None, description='Results are values that this Task can output')
    sidecars: Optional[List[Sidecar]] = Field(
        None,
        description="Sidecars are run alongside the Task's step containers. They begin before the steps start and end after the steps complete.",
    )
    spec: Optional[runtime.RawExtension] = Field({}, description='Spec is a specification of a custom task')
    step_template: Optional[v1.Container] = Field(
        None,
        alias='stepTemplate',
        description='StepTemplate can be used as the basis for all step containers within the Task, so that the steps inherit settings on the base container.',
    )
    steps: Optional[List[Step]] = Field(
        None,
        description='Steps are the steps of the build; each step is run sequentially with the source mounted into /workspace.',
    )
    volumes: Optional[List[v1.Volume]] = Field(
        None, description='Volumes is a collection of volumes that are available to mount into the steps of the build.'
    )
    workspaces: Optional[List[WorkspaceDeclaration]] = Field(
        None, description='Workspaces are the volumes that this Task requires.'
    )


class InternalTaskModifier(BaseModel):
    class Config:
        allow_population_by_field_name = True

    steps_to_append: List[Step] = Field(..., alias='StepsToAppend')
    steps_to_prepend: List[Step] = Field(..., alias='StepsToPrepend')
    volumes: List[v1.Volume] = Field(..., alias='Volumes')


class PipelineTask(BaseModel):
    class Config:
        allow_population_by_field_name = True

    conditions: Optional[List[PipelineTaskCondition]] = Field(
        None,
        description='Conditions is a list of conditions that need to be true for the task to run Conditions are deprecated, use WhenExpressions instead',
    )
    matrix: Optional[List[Param]] = Field(None, description='Matrix declares parameters used to fan out this task.')
    name: Optional[str] = Field(
        None,
        description='Name is the name of this task within the context of a Pipeline. Name is used as a coordinate with the `from` and `runAfter` fields to establish the execution order of tasks relative to one another.',
    )
    params: Optional[List[Param]] = Field(None, description='Parameters declares parameters passed to this task.')
    resources: Optional[PipelineTaskResources] = Field(
        None, description='Resources declares the resources given to this task as inputs and outputs.'
    )
    retries: Optional[int] = Field(
        None,
        description='Retries represents how many times this task should be retried in case of task failure: ConditionSucceeded set to False',
    )
    run_after: Optional[List[str]] = Field(
        None,
        alias='runAfter',
        description='RunAfter is the list of PipelineTask names that should be executed before this Task executes. (Used to force a specific ordering in graph execution.)',
    )
    task_ref: Optional[TaskRef] = Field(
        None, alias='taskRef', description='TaskRef is a reference to a task definition.'
    )
    task_spec: Optional[EmbeddedTask] = Field(
        None, alias='taskSpec', description='TaskSpec is a specification of a task'
    )
    timeout: Optional[v1.Duration] = Field(
        None,
        description="Time after which the TaskRun times out. Defaults to 1 hour. Specified TaskRun timeout should be less than 24h. Refer Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration",
    )
    when: Optional[List[WhenExpression]] = Field(
        None, description='WhenExpressions is a list of when expressions that need to be true for the task to run'
    )
    workspaces: Optional[List[WorkspacePipelineTaskBinding]] = Field(
        None, description='Workspaces maps workspaces from the pipeline spec to the workspaces declared in the Task.'
    )


class PipelineTaskRunSpec(BaseModel):
    class Config:
        allow_population_by_field_name = True

    pipeline_task_name: Optional[str] = Field(None, alias='pipelineTaskName')
    sidecar_overrides: Optional[List[TaskRunSidecarOverride]] = Field(None, alias='sidecarOverrides')
    step_overrides: Optional[List[TaskRunStepOverride]] = Field(None, alias='stepOverrides')
    task_pod_template: Optional[pod.Template] = Field(None, alias='taskPodTemplate')
    task_service_account_name: Optional[str] = Field(None, alias='taskServiceAccountName')


class Task(BaseModel):
    class Config:
        allow_population_by_field_name = True

    api_version: Optional[str] = Field(
        None,
        alias='apiVersion',
        description='APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
    )
    kind: Optional[str] = Field(
        None,
        description='Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
    )
    metadata: Optional[v1.ObjectMeta] = {}
    spec: Optional[TaskSpec] = Field({}, description='Spec holds the desired state of the Task from the client')


class TaskList(BaseModel):
    class Config:
        allow_population_by_field_name = True

    api_version: Optional[str] = Field(
        None,
        alias='apiVersion',
        description='APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
    )
    items: List[Task]
    kind: Optional[str] = Field(
        None,
        description='Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
    )
    metadata: Optional[v1.ListMeta] = {}


class TaskRunSpec(BaseModel):
    class Config:
        allow_population_by_field_name = True

    debug: Optional[TaskRunDebug] = None
    params: Optional[List[Param]] = None
    pod_template: Optional[pod.Template] = Field(
        None, alias='podTemplate', description='PodTemplate holds pod specific configuration'
    )
    resources: Optional[TaskRunResources] = None
    service_account_name: Optional[str] = Field('', alias='serviceAccountName')
    sidecar_overrides: Optional[List[TaskRunSidecarOverride]] = Field(
        None,
        alias='sidecarOverrides',
        description='Overrides to apply to Sidecars in this TaskRun. If a field is specified in both a Sidecar and a SidecarOverride, the value from the SidecarOverride will be used. This field is only supported when the alpha feature gate is enabled.',
    )
    status: Optional[str] = Field(None, description='Used for cancelling a taskrun (and maybe more later on)')
    step_overrides: Optional[List[TaskRunStepOverride]] = Field(
        None,
        alias='stepOverrides',
        description='Overrides to apply to Steps in this TaskRun. If a field is specified in both a Step and a StepOverride, the value from the StepOverride will be used. This field is only supported when the alpha feature gate is enabled.',
    )
    task_ref: Optional[TaskRef] = Field(
        None, alias='taskRef', description='no more than one of the TaskRef and TaskSpec may be specified.'
    )
    task_spec: Optional[TaskSpec] = Field(None, alias='taskSpec')
    timeout: Optional[v1.Duration] = Field(
        None,
        description="Time after which the build times out. Defaults to 1 hour. Specified build timeout should be less than 24h. Refer Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration",
    )
    workspaces: Optional[List[WorkspaceBinding]] = Field(
        None, description='Workspaces is a list of WorkspaceBindings from volumes to workspaces.'
    )


class TaskRunStatus(BaseModel):
    class Config:
        allow_population_by_field_name = True

    annotations: Optional[Dict[str, str]] = Field(
        None,
        description='Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.',
    )
    cloud_events: Optional[List[CloudEventDelivery]] = Field(
        None,
        alias='cloudEvents',
        description='CloudEvents describe the state of each cloud event requested via a CloudEventResource.',
    )
    completion_time: Optional[v1.Time] = Field(
        None, alias='completionTime', description='CompletionTime is the time the build completed.'
    )
    conditions: Optional[List[knative.Condition]] = Field(
        None, description="Conditions the latest available observations of a resource's current state."
    )
    observed_generation: Optional[int] = Field(
        None,
        alias='observedGeneration',
        description="ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
    )
    pod_name: str = Field(
        ..., alias='podName', description="PodName is the name of the pod responsible for executing this task's steps."
    )
    resources_result: Optional[List[PipelineResourceResult]] = Field(
        None,
        alias='resourcesResult',
        description='Results from Resources built during the taskRun. currently includes the digest of build container images',
    )
    retries_status: Optional[List[TaskRunStatus]] = Field(
        None,
        alias='retriesStatus',
        description='RetriesStatus contains the history of TaskRunStatus in case of a retry in order to keep record of failures. All TaskRunStatus stored in RetriesStatus will have no date within the RetriesStatus as is redundant.',
    )
    sidecars: Optional[List[SidecarState]] = Field(
        None,
        description='The list has one entry per sidecar in the manifest. Each entry is represents the imageid of the corresponding sidecar.',
    )
    start_time: Optional[v1.Time] = Field(
        None, alias='startTime', description='StartTime is the time the build is actually started.'
    )
    steps: Optional[List[StepState]] = Field(
        None, description='Steps describes the state of each build step container.'
    )
    task_results: Optional[List[TaskRunResult]] = Field(
        None,
        alias='taskResults',
        description="TaskRunResults are the list of results written out by the task's containers",
    )
    task_spec: Optional[TaskSpec] = Field(
        None,
        alias='taskSpec',
        description='TaskSpec contains the Spec from the dereferenced Task definition used to instantiate this TaskRun.',
    )


class TaskRunStatusFields(BaseModel):
    class Config:
        allow_population_by_field_name = True

    cloud_events: Optional[List[CloudEventDelivery]] = Field(
        None,
        alias='cloudEvents',
        description='CloudEvents describe the state of each cloud event requested via a CloudEventResource.',
    )
    completion_time: Optional[v1.Time] = Field(
        None, alias='completionTime', description='CompletionTime is the time the build completed.'
    )
    pod_name: str = Field(
        ..., alias='podName', description="PodName is the name of the pod responsible for executing this task's steps."
    )
    resources_result: Optional[List[PipelineResourceResult]] = Field(
        None,
        alias='resourcesResult',
        description='Results from Resources built during the taskRun. currently includes the digest of build container images',
    )
    retries_status: Optional[List[TaskRunStatus]] = Field(
        None,
        alias='retriesStatus',
        description='RetriesStatus contains the history of TaskRunStatus in case of a retry in order to keep record of failures. All TaskRunStatus stored in RetriesStatus will have no date within the RetriesStatus as is redundant.',
    )
    sidecars: Optional[List[SidecarState]] = Field(
        None,
        description='The list has one entry per sidecar in the manifest. Each entry is represents the imageid of the corresponding sidecar.',
    )
    start_time: Optional[v1.Time] = Field(
        None, alias='startTime', description='StartTime is the time the build is actually started.'
    )
    steps: Optional[List[StepState]] = Field(
        None, description='Steps describes the state of each build step container.'
    )
    task_results: Optional[List[TaskRunResult]] = Field(
        None,
        alias='taskResults',
        description="TaskRunResults are the list of results written out by the task's containers",
    )
    task_spec: Optional[TaskSpec] = Field(
        None,
        alias='taskSpec',
        description='TaskSpec contains the Spec from the dereferenced Task definition used to instantiate this TaskRun.',
    )


class ConditionCheck(BaseModel):
    class Config:
        allow_population_by_field_name = True

    api_version: Optional[str] = Field(
        None,
        alias='apiVersion',
        description='APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
    )
    kind: Optional[str] = Field(
        None,
        description='Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
    )
    metadata: Optional[v1.ObjectMeta] = {}
    spec: Optional[TaskRunSpec] = {}
    status: Optional[TaskRunStatus] = {}


class PipelineRunTaskRunStatus(BaseModel):
    class Config:
        allow_population_by_field_name = True

    condition_checks: Optional[Dict[str, PipelineRunConditionCheckStatus]] = Field(
        None, alias='conditionChecks', description='ConditionChecks maps the name of a condition check to its Status'
    )
    pipeline_task_name: Optional[str] = Field(
        None, alias='pipelineTaskName', description='PipelineTaskName is the name of the PipelineTask.'
    )
    status: Optional[TaskRunStatus] = Field(
        None, description='Status is the TaskRunStatus for the corresponding TaskRun'
    )
    when_expressions: Optional[List[WhenExpression]] = Field(
        None,
        alias='whenExpressions',
        description='WhenExpressions is the list of checks guarding the execution of the PipelineTask',
    )


class PipelineSpec(BaseModel):
    class Config:
        allow_population_by_field_name = True

    description: Optional[str] = Field(
        None, description='Description is a user-facing description of the pipeline that may be used to populate a UI.'
    )
    finally_: Optional[List[PipelineTask]] = Field(
        None,
        alias='finally',
        description='Finally declares the list of Tasks that execute just before leaving the Pipeline i.e. either after all Tasks are finished executing successfully or after a failure which would result in ending the Pipeline',
    )
    params: Optional[List[ParamSpec]] = Field(
        None, description='Params declares a list of input parameters that must be supplied when this Pipeline is run.'
    )
    resources: Optional[List[PipelineDeclaredResource]] = Field(
        None,
        description="Resources declares the names and generated of the resources given to the Pipeline's tasks as inputs and outputs.",
    )
    results: Optional[List[PipelineResult]] = Field(
        None, description='Results are values that this pipeline can output once run'
    )
    tasks: Optional[List[PipelineTask]] = Field(
        None, description='Tasks declares the graph of Tasks that execute when this Pipeline is run.'
    )
    workspaces: Optional[List[PipelineWorkspaceDeclaration]] = Field(
        None,
        description='Workspaces declares a set of named workspaces that are expected to be provided by a PipelineRun.',
    )


class TaskRun(BaseModel):
    class Config:
        allow_population_by_field_name = True

    api_version: Optional[str] = Field(
        None,
        alias='apiVersion',
        description='APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
    )
    kind: Optional[str] = Field(
        None,
        description='Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
    )
    metadata: Optional[v1.ObjectMeta] = {}
    spec: Optional[TaskRunSpec] = {}
    status: Optional[TaskRunStatus] = {}


class TaskRunList(BaseModel):
    class Config:
        allow_population_by_field_name = True

    api_version: Optional[str] = Field(
        None,
        alias='apiVersion',
        description='APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
    )
    items: List[TaskRun]
    kind: Optional[str] = Field(
        None,
        description='Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
    )
    metadata: Optional[v1.ListMeta] = {}


class Pipeline(BaseModel):
    class Config:
        allow_population_by_field_name = True

    api_version: Optional[str] = Field(
        None,
        alias='apiVersion',
        description='APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
    )
    kind: Optional[str] = Field(
        None,
        description='Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
    )
    metadata: Optional[v1.ObjectMeta] = {}
    spec: Optional[PipelineSpec] = Field({}, description='Spec holds the desired state of the Pipeline from the client')


class PipelineList(BaseModel):
    class Config:
        allow_population_by_field_name = True

    api_version: Optional[str] = Field(
        None,
        alias='apiVersion',
        description='APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
    )
    items: List[Pipeline]
    kind: Optional[str] = Field(
        None,
        description='Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
    )
    metadata: Optional[v1.ListMeta] = {}


class PipelineRunSpec(BaseModel):
    class Config:
        allow_population_by_field_name = True

    params: Optional[List[Param]] = Field(None, description='Params is a list of parameter names and values.')
    pipeline_ref: Optional[PipelineRef] = Field(None, alias='pipelineRef')
    pipeline_spec: Optional[PipelineSpec] = Field(None, alias='pipelineSpec')
    pod_template: Optional[pod.Template] = Field(
        None, alias='podTemplate', description='PodTemplate holds pod specific configuration'
    )
    resources: Optional[List[PipelineResourceBinding]] = Field(
        None,
        description='Resources is a list of bindings specifying which actual instances of PipelineResources to use for the resources the Pipeline has declared it needs.',
    )
    service_account_name: Optional[str] = Field(None, alias='serviceAccountName')
    service_account_names: Optional[List[PipelineRunSpecServiceAccountName]] = Field(
        None, alias='serviceAccountNames', description='Deprecated: use taskRunSpecs.ServiceAccountName instead'
    )
    status: Optional[str] = Field(None, description='Used for cancelling a pipelinerun (and maybe more later on)')
    task_run_specs: Optional[List[PipelineTaskRunSpec]] = Field(
        None, alias='taskRunSpecs', description='TaskRunSpecs holds a set of runtime specs'
    )
    timeout: Optional[v1.Duration] = Field(
        None,
        description="Time after which the Pipeline times out. Defaults to never. Refer to Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration",
    )
    timeouts: Optional[TimeoutFields] = Field(
        None,
        description='This is an alpha field. You must set the "enable-api-fields" feature flag to "alpha" for this field to be supported.\n\nTime after which the Pipeline times out. Currently three keys are accepted in the map pipeline, tasks and finally with Timeouts.pipeline >= Timeouts.tasks + Timeouts.finally',
    )
    workspaces: Optional[List[WorkspaceBinding]] = Field(
        None,
        description='Workspaces holds a set of workspace bindings that must match names with those declared in the pipeline.',
    )


class PipelineRunStatus(BaseModel):
    class Config:
        allow_population_by_field_name = True

    annotations: Optional[Dict[str, str]] = Field(
        None,
        description='Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.',
    )
    child_references: Optional[List[ChildStatusReference]] = Field(
        None,
        alias='childReferences',
        description='list of TaskRun and Run names, PipelineTask names, and API versions/kinds for children of this PipelineRun.',
    )
    completion_time: Optional[v1.Time] = Field(
        None, alias='completionTime', description='CompletionTime is the time the PipelineRun completed.'
    )
    conditions: Optional[List[knative.Condition]] = Field(
        None, description="Conditions the latest available observations of a resource's current state."
    )
    observed_generation: Optional[int] = Field(
        None,
        alias='observedGeneration',
        description="ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
    )
    pipeline_results: Optional[List[PipelineRunResult]] = Field(
        None,
        alias='pipelineResults',
        description="PipelineResults are the list of results written out by the pipeline task's containers",
    )
    pipeline_spec: Optional[PipelineSpec] = Field(
        None, alias='pipelineSpec', description='PipelineRunSpec contains the exact spec used to instantiate the run'
    )
    runs: Optional[Dict[str, PipelineRunRunStatus]] = Field(
        None,
        description='Deprecated - use ChildReferences instead. map of PipelineRunRunStatus with the run name as the key',
    )
    skipped_tasks: Optional[List[SkippedTask]] = Field(
        None,
        alias='skippedTasks',
        description='list of tasks that were skipped due to when expressions evaluating to false',
    )
    start_time: Optional[v1.Time] = Field(
        None, alias='startTime', description='StartTime is the time the PipelineRun is actually started.'
    )
    task_runs: Optional[Dict[str, PipelineRunTaskRunStatus]] = Field(
        None,
        alias='taskRuns',
        description='Deprecated - use ChildReferences instead. map of PipelineRunTaskRunStatus with the taskRun name as the key',
    )


class PipelineRunStatusFields(BaseModel):
    class Config:
        allow_population_by_field_name = True

    child_references: Optional[List[ChildStatusReference]] = Field(
        None,
        alias='childReferences',
        description='list of TaskRun and Run names, PipelineTask names, and API versions/kinds for children of this PipelineRun.',
    )
    completion_time: Optional[v1.Time] = Field(
        None, alias='completionTime', description='CompletionTime is the time the PipelineRun completed.'
    )
    pipeline_results: Optional[List[PipelineRunResult]] = Field(
        None,
        alias='pipelineResults',
        description="PipelineResults are the list of results written out by the pipeline task's containers",
    )
    pipeline_spec: Optional[PipelineSpec] = Field(
        None, alias='pipelineSpec', description='PipelineRunSpec contains the exact spec used to instantiate the run'
    )
    runs: Optional[Dict[str, PipelineRunRunStatus]] = Field(
        None,
        description='Deprecated - use ChildReferences instead. map of PipelineRunRunStatus with the run name as the key',
    )
    skipped_tasks: Optional[List[SkippedTask]] = Field(
        None,
        alias='skippedTasks',
        description='list of tasks that were skipped due to when expressions evaluating to false',
    )
    start_time: Optional[v1.Time] = Field(
        None, alias='startTime', description='StartTime is the time the PipelineRun is actually started.'
    )
    task_runs: Optional[Dict[str, PipelineRunTaskRunStatus]] = Field(
        None,
        alias='taskRuns',
        description='Deprecated - use ChildReferences instead. map of PipelineRunTaskRunStatus with the taskRun name as the key',
    )


class PipelineRun(BaseModel):
    class Config:
        allow_population_by_field_name = True

    api_version: Optional[str] = Field(
        None,
        alias='apiVersion',
        description='APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
    )
    kind: Optional[str] = Field(
        None,
        description='Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
    )
    metadata: Optional[v1.ObjectMeta] = {}
    spec: Optional[PipelineRunSpec] = {}
    status: Optional[PipelineRunStatus] = {}


class PipelineRunList(BaseModel):
    class Config:
        allow_population_by_field_name = True

    api_version: Optional[str] = Field(
        None,
        alias='apiVersion',
        description='APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
    )
    items: Optional[List[PipelineRun]] = None
    kind: Optional[str] = Field(
        None,
        description='Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
    )
    metadata: Optional[v1.ListMeta] = {}


TaskRunStatus.update_forward_refs()
